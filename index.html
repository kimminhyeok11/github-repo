<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>크로노사인: 서바이버</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --dark-bg: #000000;
            --panel-bg: rgba(10, 10, 10, 0.9);
            --border-color: #5a4a3a;
            --gold-color: #D4AF37;
            --red-color: #a01c1c;
            --xp-color: #6d28d9;
        }
        body, html { 
            font-family: 'Noto Sans KR', sans-serif; 
            background-color: var(--dark-bg); 
            color: #c7c7c7; 
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        .font-cinzel { font-family: 'Cinzel', serif; }
        .hidden { display: none !important; }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        /* UI Elements */
        #top-ui {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
            pointer-events: none;
        }
        #stage-progress-bar-bg {
            background-color: #222;
            border: 2px solid var(--border-color);
            padding: 2px;
            border-radius: 5px;
        }
        #stage-progress-bar {
            height: 15px;
            background: linear-gradient(to right, #fde047, #f59e0b);
            width: 0%;
            transition: width 0.3s;
            border-radius: 2px;
        }
        #stage-text {
            text-align: center;
            color: white;
            font-family: 'Cinzel', serif;
            margin-top: 4px;
            text-shadow: 1px 1px 2px black;
        }

        #game-ui-bottom {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            pointer-events: none;
        }
        #xp-bar-bg {
            width: 60%;
            max-width: 400px;
            height: 12px;
            background-color: #222;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 10px;
        }
        #xp-bar {
            height: 100%;
            background: linear-gradient(to right, #8b5cf6, #a78bfa);
            width: 0%;
            transition: width 0.3s;
            border-radius: 4px;
        }
        #level-text {
            position: absolute;
            bottom: 25px;
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
        }
        
        .orb {
            position: fixed;
            bottom: 10px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background-color: #000;
            border: 4px solid #4a4a4a;
            overflow: hidden;
        }
        #health-orb { left: 10px; }
        
        .orb-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background-color: var(--red-color);
            transition: height 0.2s;
        }
        .orb-text {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            text-shadow: 1px 1px 2px black;
        }

        /* Modal Windows */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .modal-panel {
            background-color: var(--panel-bg);
            border: 3px solid var(--border-color);
            box-shadow: 0 0 20px black;
            padding: 1.5rem;
            width: 90%;
            max-width: 600px;
            border-radius: 8px;
        }
        .modal-title {
            font-family: 'Cinzel', serif;
            color: var(--gold-color);
            text-align: center;
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .upgrade-card {
            background-color: #1a1a1a;
            border: 2px solid var(--border-color);
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 6px;
        }
        .upgrade-card:hover {
            border-color: var(--gold-color);
            transform: translateY(-5px);
        }
        
        .game-button {
            background: linear-gradient(to bottom, #a37d2a, #825e1a);
            border: 2px solid #5a4a3a;
            color: white;
            font-family: 'Cinzel', serif;
            border-radius: 5px;
            text-shadow: 1px 1px 2px black;
            transition: all 0.2s;
            box-shadow: 0 4px #4d3c28;
        }
        .game-button:hover {
            background: linear-gradient(to bottom, #b88d30, #966c1e);
            transform: translateY(-2px);
            box-shadow: 0 6px #4d3c28;
        }
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #4d3c28;
        }


        /* Mobile Controls */
        .joystick-container {
            position: fixed;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .control-base {
            position: absolute;
            width: 100px;
            height: 100px;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255,255,255,0.2);
        }
        .control-stick {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.4);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #skill-cooldown-overlay {
            position: absolute;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.6);
            clip-path: inset(100% 0 0 0);
            transition: clip-path 0.1s linear;
        }
        
        /* VFX */
        .damage-text {
            position: absolute;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            z-index: 150;
        }
        #player-hit-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(255, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            z-index: 200;
        }
        #notification-panel {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 201;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .notification {
            background-color: var(--panel-bg);
            color: var(--gold-color);
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid var(--border-color);
            font-family: 'Cinzel', serif;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="game-canvas" tabindex="1"></canvas>
        <div id="vfx-container"></div>
        <div id="player-hit-overlay"></div>
        <div id="notification-panel"></div>
        
        <div id="top-ui" class="hidden">
            <div id="stage-progress-bar-bg">
                <div id="stage-progress-bar"></div>
            </div>
            <p id="stage-text">STAGE 1</p>
        </div>

        <div id="game-ui-bottom" class="hidden">
            <div id="xp-bar-bg">
                <div id="xp-bar"></div>
            </div>
            <p id="level-text">LV. 1</p>
        </div>
        
        <div id="health-orb" class="orb hidden">
            <div id="health-orb-fill" class="orb-fill"></div>
            <div id="health-orb-text" class="orb-text"></div>
        </div>
        
        <div id="joystick-area" class="joystick-container">
            <div class="control-base"></div>
            <div id="joystick-stick" class="control-stick"></div>
        </div>
        <div id="skill-joystick-area" class="joystick-container">
            <div class="control-base">
                <div id="skill-cooldown-overlay"></div>
            </div>
            <div id="skill-joystick-stick" class="control-stick"></div>
        </div>
        
        <div id="modals-container">
            <div id="intro-screen" class="modal-overlay">
                <div class="modal-panel text-center">
                    <h1 class="modal-title text-2xl">크로노사인: 서바이버</h1>
                    <p class="mb-6 text-gray-400">시간의 균열이 열리고, 모든 시대의 괴물들이 쏟아져 나옵니다. 당신은 이 혼돈 속에서 살아남아야 하는 유일한 희망입니다. 끊임없이 몰려오는 적들을 처치하고, 힘을 키워 균열의 근원을 파괴하십시오.</p>
                    <button id="start-game-btn" class="game-button text-base py-2 px-8">게임 시작</button>
                </div>
            </div>
            <div id="hero-selection-screen" class="modal-overlay hidden"></div>
            <div id="level-up-modal" class="modal-overlay hidden"></div>
            <div id="game-over-modal" class="modal-overlay hidden"></div>
        </div>
    </div>

    <script type="module">
        // --- GAME DATA ---
        const HEROES = {
            kaelan: { name: "카엘란", baseStats: { hp: 120, str: 15, vit: 12, agi: 8 } },
            lyra: { name: "라이라", baseStats: { hp: 80, str: 8, vit: 7, agi: 15 } },
        };
        const WEAPONS = {
            magic_missile: { 
                name: "매직 미사일", type: 'projectile', power: 1.0, speed: 7, size: 5, cooldown: 500, maxLevel: 4,
                description: "가장 가까운 적에게 미사일을 발사합니다.",
                evolution: [
                    { level: 2, projectiles: 2, description: "발사체 2개로 증가" }, 
                    { level: 3, projectiles: 4, description: "발사체 4개로 증가" }, 
                    { level: 4, power: 1.5, size: 7, description: "공격력 및 크기 증가" },
                ]
            },
            chain_lightning: {
                name: "체인 라이트닝", type: 'chain', power: 0.8, cooldown: 2000, chains: 3, range: 150, maxLevel: 4,
                description: "적에게 튕기는 번개를 발사합니다.",
                evolution: [ { level: 2, chains: 5, description: "최대 5번 연쇄" }, { level: 3, power: 1.2, description: "공격력 증가" }, { level: 4, chains: 7, range: 200, description: "최대 7번 연쇄, 범위 증가" } ]
            },
            fire_pulse: {
                name: "화염 파동", type: 'pulse_aura', power: 0.3, cooldown: 2500, radius: 120, maxLevel: 4,
                description: "주기적으로 주변에 화염 파동을 방출하여 피해를 줍니다.",
                evolution: [ { level: 2, radius: 150, description: "범위 증가" }, { level: 3, power: 0.5, description: "공격력 증가" }, { level: 4, cooldown: 2000, description: "쿨타임 감소" } ]
            },
            ice_shards: {
                name: "얼음 파편", type: 'projectile', power: 0.7, speed: 6, size: 4, cooldown: 1500, projectiles: 8, is360: true, maxLevel: 4,
                description: "모든 방향으로 얼음 파편을 발사합니다.",
                evolution: [ { level: 2, projectiles: 12, description: "파편 12개로 증가" }, { level: 3, power: 1.0, description: "공격력 증가" }, { level: 4, projectiles: 16, description: "파편 16개로 증가" } ]
            },
            holy_water: {
                name: "성수", type: 'ground_aoe', power: 0.6, cooldown: 3000, radius: 80, duration: 4000, maxLevel: 4,
                description: "성수 병을 던져 신성한 지대를 생성합니다.",
                evolution: [
                    { level: 2, power: 0.8, description: "공격력 증가" },
                    { level: 3, radius: 100, description: "범위 증가" },
                    { level: 4, duration: 6000, description: "지속시간 증가" }
                ]
            }
        };
        const MONSTERS = {
            goblin: { name: "고블린", stats: { hp: 80, str: 12, vit: 5, agi: 5 }, xp: 25, radius: 12, color: '#964B00' },
            bat: { name: "박쥐", stats: { hp: 50, str: 8, vit: 2, agi: 8 }, xp: 15, radius: 10, color: '#4B0082' },
            ogre: { name: "오우거", stats: { hp: 250, str: 25, vit: 10, agi: 3 }, xp: 50, radius: 20, color: '#808080' },
            cyclops: { name: "사이클롭스", stats: { hp: 1000, str: 40, vit: 15, agi: 2 }, xp: 200, radius: 30, color: '#D2691E' },
            skeleton: { name: "스켈레톤", stats: { hp: 150, str: 20, vit: 8, agi: 4 }, xp: 40, radius: 14, color: '#E0E0E0' },
            slime: { name: "슬라임", stats: { hp: 100, str: 15, vit: 10, agi: 3 }, xp: 20, radius: 15, color: '#34D399', splits: true },
            mini_slime: { name: "미니 슬라임", stats: { hp: 30, str: 8, vit: 2, agi: 5 }, xp: 5, radius: 8, color: '#6EE7B7' },
            minotaur: { name: "미노타우로스", stats: { hp: 2500, str: 60, vit: 25, agi: 3 }, xp: 1000, radius: 35, color: '#A0522D' }
        };
        const STAGES = [
            { duration: 60, monsterTypes: ['goblin'], difficulty: 1.0 },
            { duration: 80, monsterTypes: ['goblin', 'bat'], difficulty: 1.2 },
            { duration: 1, monsterTypes: [], boss: 'cyclops', difficulty: 1.5 },
            { duration: 90, monsterTypes: ['bat', 'skeleton'], difficulty: 1.8 },
            { duration: 100, monsterTypes: ['skeleton', 'slime'], difficulty: 2.2 },
            { duration: 1, monsterTypes: [], boss: 'minotaur', difficulty: 2.5 },
            { duration: Infinity, monsterTypes: ['goblin', 'bat', 'skeleton', 'slime', 'ogre'], difficulty: 3.0 } // Endless Horde mode
        ];
        const UPGRADE_POOL = ['chain_lightning', 'fire_pulse', 'ice_shards', 'holy_water'];

        // --- GAME STATE & SETUP ---
        let gameState = {};
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        let camera = { x: 0, y: 0 };
        let moveJoystick = { active: false, dx: 0, dy: 0, touchId: null, startX: 0, startY: 0 };
        let skillJoystick = { active: false, angle: 0, intensity: 0, touchId: null, startX: 0, startY: 0 };
        const keys = {};
        const MAP_SIZE = { width: 3000, height: 3000 };
        let sounds = {};
        let animationFrameId;
        let lastHitSoundTime = 0;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // --- DOM ELEMENTS ---
        const DOMElements = {
            introScreen: document.getElementById('intro-screen'),
            heroSelection: document.getElementById('hero-selection-screen'),
            levelUpModal: document.getElementById('level-up-modal'),
            gameOverModal: document.getElementById('game-over-modal'),
            healthOrb: document.getElementById('health-orb'),
            healthOrbFill: document.getElementById('health-orb-fill'),
            healthOrbText: document.getElementById('health-orb-text'),
            xpBar: document.getElementById('xp-bar'),
            levelText: document.getElementById('level-text'),
            stageProgress: document.getElementById('stage-progress-bar'),
            stageText: document.getElementById('stage-text'),
            joystickArea: document.getElementById('joystick-area'),
            joystickStick: document.getElementById('joystick-stick'),
            skillJoystickArea: document.getElementById('skill-joystick-area'),
            skillJoystickStick: document.getElementById('skill-joystick-stick'),
            skillCooldownOverlay: document.getElementById('skill-cooldown-overlay'),
            topUI: document.getElementById('top-ui'),
            bottomUI: document.getElementById('game-ui-bottom'),
            vfxContainer: document.getElementById('vfx-container'),
        };

        // --- CORE FUNCTIONS ---
        function init() {
            setupEventListeners();
        }

        function startGame(heroId) {
            const heroData = HEROES[heroId];
            gameState = {
                player: {
                    ...heroData,
                    x: MAP_SIZE.width / 2, y: MAP_SIZE.height / 2,
                    radius: 15, speed: 3,
                    level: 1, xp: 0, xpToNextLevel: 50,
                    activeWeapons: [{ id: 'magic_missile', level: 1, lastFired: 0 }],
                    invincibleUntil: 0,
                    attackRange: 0,
                    statBonuses: { hp: 1, power: 1, speed: 1 },
                    grenade: {
                        cooldown: 8000,
                        lastUsed: -8000,
                        throwRange: 300,
                        blastRadius: 100,
                        power: 2.5,
                        fuse: 1500,
                    },
                },
                monsters: [],
                xpOrbs: [],
                projectiles: [],
                vfx: [],
                stage: 0,
                stageStartTime: Date.now(),
                difficulty: 1.0,
                killCount: 0,
                isPaused: false,
                isGameOver: false,
            };
            recalculatePlayerStats();
            DOMElements.heroSelection.classList.add('hidden');
            
            DOMElements.topUI.classList.remove('hidden');
            DOMElements.bottomUI.classList.remove('hidden');
            DOMElements.healthOrb.classList.remove('hidden');
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }
        
        function recalculatePlayerStats() {
            const p = gameState.player;
            p.effectiveStats = { ...p.baseStats };
            p.effectiveStats.hp = (p.baseStats.hp + (p.effectiveStats.vit * 10)) * p.statBonuses.hp;
            p.speed = 3 * p.statBonuses.speed; // Base speed is 3
            if (p.currentHp === undefined || p.currentHp > p.effectiveStats.hp) p.currentHp = p.effectiveStats.hp;
            
            p.attackRange = 0;
            p.activeWeapons.forEach(w => {
                const weaponData = WEAPONS[w.id];
                if (weaponData.range || weaponData.type === 'pulse_aura') {
                    const evolutionLevels = weaponData.evolution.filter(e => w.level >= e.level);
                    const evolution = evolutionLevels.reduce((acc, val) => ({...acc, ...val}), {});
                    const currentRange = evolution.range || evolution.radius || weaponData.range || weaponData.radius;
                    if (currentRange > p.attackRange) p.attackRange = currentRange;
                }
            });
        }

        function spawnMonster() {
            if (!gameState.player) return;
            const currentStage = STAGES[gameState.stage];
            if (!currentStage || currentStage.boss) return;

            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(canvas.width, canvas.height) / 2 + 50;
            const x = gameState.player.x + Math.cos(angle) * radius;
            const y = gameState.player.y + Math.sin(angle) * radius;
            
            const monsterId = currentStage.monsterTypes[Math.floor(Math.random() * currentStage.monsterTypes.length)];
            const monsterData = JSON.parse(JSON.stringify(MONSTERS[monsterId]));
            
            const diff = gameState.difficulty;
            monsterData.stats.hp *= diff;
            monsterData.stats.str *= diff;
            monsterData.speed = (MONSTERS[monsterId].stats.agi * 0.2) * Math.min(1.5, diff); // Cap speed increase

            gameState.monsters.push({
                ...monsterData, x, y,
                currentHp: monsterData.stats.hp,
            });
        }
        
        // --- SOUND MANAGER ---
        function setupSounds() {
            sounds.shoot = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }
            }).toDestination();
            sounds.hit = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0 } }).toDestination();
            sounds.xp = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sine' },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 }
            }).toDestination();
            sounds.levelUp = new Tone.PolySynth(Tone.Synth).toDestination();
            sounds.throw = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
            sounds.explosion = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.2 } }).toDestination();
        }

        function playSound(effect, options = {}) {
            if (!sounds[effect] || Tone.context.state !== 'running') return;
            
            switch (effect) {
                case 'shoot': 
                    sounds.shoot.triggerAttackRelease('C5', '16n'); 
                    break;
                case 'hit': 
                    {
                        const now = Tone.now();
                        if (now - lastHitSoundTime > 0.05) { // Throttle hit sound
                            sounds.hit.triggerAttackRelease('8n');
                            lastHitSoundTime = now;
                        }
                    }
                    break;
                case 'xp': 
                    sounds.xp.triggerAttackRelease(options.note || 'A5', '16n'); 
                    break;
                case 'levelUp': 
                    sounds.levelUp.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '8n'); 
                    break;
                case 'throw': 
                    sounds.throw.triggerAttackRelease('G4', '8n'); 
                    break;
                case 'explosion': 
                    sounds.explosion.triggerAttackRelease('2n'); 
                    break;
            }
        }
        
        // --- GAME LOOP & DRAWING ---
        let lastSpawnTime = 0;
        function gameLoop() {
            if (gameState.isGameOver) return;

            const now = Date.now();
            if (!gameState.isPaused) {
                update(now);
                if (now - lastSpawnTime > (500 - gameState.stage * 50)) { // Spawn rate increases with stage
                    spawnMonster();
                    lastSpawnTime = now;
                }
            }
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function update(now) {
            updateStage(now);
            updatePlayer(now);
            updateMonsters(now);
            updateProjectiles();
            updateXpOrbs();
            updateVFX(now);
        }

        function draw() {
            if (!gameState.player) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            camera.x = gameState.player.x - canvas.width / 2;
            camera.y = gameState.player.y - canvas.height / 2;
            
            const buffer = 50;
            const cameraBounds = {
                left: camera.x - buffer,
                right: camera.x + canvas.width + buffer,
                top: camera.y - buffer,
                bottom: camera.y + canvas.height + buffer
            };

            drawMap();
            drawXpOrbs(cameraBounds);
            drawProjectiles(cameraBounds);
            drawVFX(cameraBounds);
            drawMonsters(cameraBounds);
            drawPlayer();
            drawGrenadeTrajectory();
            updateUI();
        }

        function drawMap() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const startX = -camera.x % gridSize;
            const startY = -camera.y % gridSize;
            
            for(let x = startX; x < canvas.width; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for(let y = startY; y < canvas.height; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
        }

        function drawCharacter(char) {
            const gradient = ctx.createRadialGradient(
                char.x - camera.x, char.y - camera.y, char.radius * 0.2,
                char.x - camera.x, char.y - camera.y, char.radius
            );
            gradient.addColorStop(0, char.color);
            gradient.addColorStop(1, 'black');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(char.x - camera.x, char.y - camera.y, char.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlayer() { 
            const p = gameState.player;
            if (Date.now() < p.invincibleUntil) {
                ctx.globalAlpha = 0.5;
            }
            drawCharacter({...p, color: '#3b82f6'}); 
            ctx.globalAlpha = 1.0;
            
            if (p.attackRange > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, p.attackRange, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        function drawMonsters(bounds) {
            for (const m of gameState.monsters) {
                if (m.x + m.radius > bounds.left && m.x - m.radius < bounds.right &&
                    m.y + m.radius > bounds.top && m.y - m.radius < bounds.bottom) {
                    drawCharacter(m);
                }
            }
        }
        
        function drawXpOrbs(bounds) {
            ctx.fillStyle = '#a78bfa';
            for (const orb of gameState.xpOrbs) {
                 if (orb.x + orb.radius > bounds.left && orb.x - orb.radius < bounds.right &&
                    orb.y + orb.radius > bounds.top && orb.y - orb.radius < bounds.bottom) {
                    ctx.beginPath();
                    ctx.arc(orb.x - camera.x, orb.y - camera.y, orb.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawProjectiles(bounds) {
            for (const p of gameState.projectiles) {
                 if (p.x + p.size > bounds.left && p.x - p.size < bounds.right &&
                    p.y + p.size > bounds.top && p.y - p.size < bounds.bottom) {
                    ctx.fillStyle = p.color || 'white';
                    ctx.beginPath();
                    ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        function drawVFX(bounds) {
             for (const v of gameState.vfx) {
                if (v.x + (v.radius || 0) > bounds.left && v.x - (v.radius || 0) < bounds.right &&
                    v.y + (v.radius || 0) > bounds.top && v.y - (v.radius || 0) < bounds.bottom) {
                    ctx.save();
                    ctx.globalAlpha = v.opacity;
                    if (v.type === 'chain') {
                        ctx.strokeStyle = v.color;
                        ctx.lineWidth = v.width;
                        ctx.beginPath();
                        ctx.moveTo(v.startX - camera.x, v.startY - camera.y);
                        ctx.lineTo(v.endX - camera.x, v.endY - camera.y);
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = v.color;
                        ctx.beginPath();
                        ctx.arc(v.x - camera.x, v.y - camera.y, v.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }
        }

        function drawGrenadeTrajectory() {
            const p = gameState.player;
            if (!skillJoystick.active || !p) return;
            
            const now = Date.now();
            const isReady = now > p.grenade.lastUsed + p.grenade.cooldown;
            if (!isReady) return;

            const startX = p.x - camera.x;
            const startY = p.y - camera.y;
            
            const currentThrowRange = p.grenade.throwRange * skillJoystick.intensity;
            const endX = p.x + Math.cos(skillJoystick.angle) * currentThrowRange - camera.x;
            const endY = p.y + Math.sin(skillJoystick.angle) * currentThrowRange - camera.y;

            ctx.save();
            ctx.setLineDash([10, 10]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(endX, endY, p.grenade.blastRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        // --- UPDATE LOGIC ---
        function updateStage(now) {
            const currentStageData = STAGES[gameState.stage];
            if (!currentStageData) return;

            gameState.difficulty = currentStageData.difficulty;
            if (currentStageData.duration === Infinity) {
                // Increase difficulty over time in endless mode
                gameState.difficulty += (now - gameState.stageStartTime) / (1000 * 300); // Increase every 5 mins
            }

            if (currentStageData.boss) {
                const bossExists = gameState.monsters.some(m => m.name === MONSTERS[currentStageData.boss].name);
                if (!bossExists && gameState.monsters.length === 0) {
                    advanceStage(now);
                }
            } else {
                const elapsedTime = (now - gameState.stageStartTime) / 1000;
                if (elapsedTime >= currentStageData.duration) {
                    advanceStage(now);
                }
            }
        }

        function advanceStage(now) {
            gameState.stage++;
            gameState.stageStartTime = now;
            const nextStage = STAGES[gameState.stage];
            if (nextStage && nextStage.boss) {
                spawnBoss(nextStage.boss);
            }
        }

        function updatePlayer(now) {
            const p = gameState.player;
            let dx = 0, dy = 0;
            
            if (moveJoystick.active) {
                dx = moveJoystick.dx;
                dy = moveJoystick.dy;
            } else {
                if (keys['w'] || keys['ArrowUp']) dy = -1;
                if (keys['s'] || keys['ArrowDown']) dy = 1;
                if (keys['a'] || keys['ArrowLeft']) dx = -1;
                if (keys['d'] || keys['ArrowRight']) dx = 1;
            }
            if (dx !== 0 || dy !== 0) {
                const magnitude = Math.hypot(dx, dy); // Normalize keyboard input
                p.x += (dx / magnitude) * p.speed;
                p.y += (dy / magnitude) * p.speed;
            }
            p.x = Math.max(p.radius, Math.min(MAP_SIZE.width - p.radius, p.x));
            p.y = Math.max(p.radius, Math.min(MAP_SIZE.height - p.radius, p.y));
            
            p.activeWeapons.forEach(weapon => {
                if (now > (weapon.lastFired || 0)) {
                    handlePlayerAttack(weapon, now);
                }
            });
        }

        function updateMonsters(now) {
            const p = gameState.player;
            gameState.monsters.forEach(m => {
                const dist = Math.hypot(p.x - m.x, p.y - m.y);
                const angle = Math.atan2(p.y - m.y, p.x - m.x);
                m.x += Math.cos(angle) * m.speed;
                m.y += Math.sin(angle) * m.speed;
                
                if (dist < p.radius + m.radius && now > p.invincibleUntil) {
                    p.currentHp -= m.stats.str;
                    p.invincibleUntil = now + 500;
                    createDamageText(p, m.stats.str, '#ff4d4d');
                    anime({ targets: '#player-hit-overlay', opacity: [1, 0], duration: 300, easing: 'easeOutQuad' });
                    if (p.currentHp <= 0) gameOver();
                }
            });
        }

        function updateProjectiles() {
            for(let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const p = gameState.projectiles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.lifespan--;

                for(let j = gameState.monsters.length - 1; j >= 0; j--) {
                    const m = gameState.monsters[j];
                    if (Math.hypot(p.x - m.x, p.y - m.y) < m.radius + p.size) {
                        m.currentHp -= p.damage;
                        createDamageText(m, p.damage, 'white');
                        playSound('hit');
                        gameState.projectiles.splice(i, 1);
                        if (m.currentHp <= 0) handleMonsterDeath(m, j);
                        return;
                    }
                }
                if (p.lifespan <= 0) gameState.projectiles.splice(i, 1);
            }
        }
        
        function updateVFX(now) {
             for (let i = gameState.vfx.length - 1; i >= 0; i--) {
                const v = gameState.vfx[i];
                if (v.update) v.update(now);
                if (now > v.destroyTime) {
                    gameState.vfx.splice(i, 1);
                }
            }
        }

        function updateXpOrbs() {
            const p = gameState.player;
            for(let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                const dist = Math.hypot(p.x - orb.x, p.y - orb.y);
                if (dist < 100) {
                    const angle = Math.atan2(p.y - orb.y, p.x - orb.x);
                    orb.x += Math.cos(angle) * 5;
                    orb.y += Math.sin(angle) * 5;
                }
                if (dist < p.radius) {
                    p.xp += orb.value;
                    playSound('xp', {note: 'C6'});
                    if (p.xp >= p.xpToNextLevel) levelUp();
                    gameState.xpOrbs.splice(i, 1);
                }
            }
        }

        function handlePlayerAttack(weaponInstance, now) {
            const p = gameState.player;
            const weaponData = WEAPONS[weaponInstance.id];
            
            const evolutionLevels = weaponData.evolution.filter(e => weaponInstance.level >= e.level);
            const evolution = evolutionLevels.reduce((acc, val) => ({...acc, ...val}), {});

            const cooldown = evolution.cooldown || weaponData.cooldown;
            weaponInstance.lastFired = now + (cooldown / (p.effectiveStats.agi * 0.1));
            const power = weaponData.power * (evolution.power || 1) * p.statBonuses.power;
            const damage = Math.max(1, Math.floor(p.effectiveStats.str * power));

            const findNearestEnemy = (from, exclude = [], maxRange = Infinity) => {
                let nearest = null; let minDistance = Infinity;
                for(const m of gameState.monsters) {
                    if (exclude.includes(m)) continue;
                    const dist = Math.hypot(from.x - m.x, from.y - m.y);
                    if (dist < minDistance && dist < maxRange) {
                        minDistance = dist;
                        nearest = m;
                    }
                }
                return { enemy: nearest, distance: minDistance };
            };

            const { enemy: nearestEnemy, distance: nearestDist } = findNearestEnemy(p, [], canvas.width);
            if (!nearestEnemy && !['pulse_aura', 'ground_aoe'].includes(weaponData.type) && !weaponData.is360) return;
            
            let targetAngle = nearestEnemy ? Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x) : 0;

            switch (weaponData.type) {
                case 'projectile': {
                    playSound('shoot');
                    const numProjectiles = evolution.projectiles || weaponData.projectiles || 1;
                    const angleSpread = weaponData.is360 ? (Math.PI * 2 / numProjectiles) : (evolution.angleSpread || 0.2);
                    const baseAngle = targetAngle - (angleSpread * (numProjectiles - 1)) / 2;

                    for (let i = 0; i < numProjectiles; i++) {
                        const currentAngle = weaponData.is360 ? i * angleSpread + (targetAngle * !weaponData.is360) : baseAngle + i * angleSpread;
                        gameState.projectiles.push({
                            x: p.x, y: p.y,
                            vx: Math.cos(currentAngle) * weaponData.speed,
                            vy: Math.sin(currentAngle) * weaponData.speed,
                            damage: damage,
                            size: evolution.size || weaponData.size,
                            lifespan: 100,
                            color: weaponInstance.id === 'ice_shards' ? '#60a5fa' : 'white',
                        });
                    }
                    break;
                }
                case 'chain': {
                    if (!nearestEnemy || nearestDist > (evolution.range || weaponData.range)) return;
                    
                    let currentTarget = nearestEnemy;
                    let lastTarget = p;
                    const hitEnemies = [nearestEnemy];
                    const maxChains = evolution.chains || weaponData.chains;

                    for(let i = 0; i < maxChains; i++) {
                        if (!currentTarget) break;
                        currentTarget.currentHp -= damage;
                        createDamageText(currentTarget, damage, '#facc15');
                        if (currentTarget.currentHp <= 0) handleMonsterDeath(currentTarget, gameState.monsters.indexOf(currentTarget));
                        
                        createLineVFX(lastTarget.x, lastTarget.y, currentTarget.x, currentTarget.y, '#facc15', 3, 100);
                        
                        lastTarget = currentTarget;
                        const { enemy: nextTarget } = findNearestEnemy(currentTarget, hitEnemies);
                        if (nextTarget && Math.hypot(currentTarget.x - nextTarget.x, currentTarget.y - nextTarget.y) < (evolution.range || weaponData.range)) {
                            currentTarget = nextTarget;
                            hitEnemies.push(nextTarget);
                        } else {
                            currentTarget = null;
                        }
                    }
                    break;
                }
                case 'pulse_aura': {
                    const radius = evolution.radius || weaponData.radius;
                    createExpandingRingVFX(p.x, p.y, radius, '#ff9900', 300);
                    for(const m of gameState.monsters) {
                        if (Math.hypot(p.x - m.x, p.y - m.y) < radius) {
                            m.currentHp -= damage;
                            createDamageText(m, damage, '#ff9900');
                            if (m.currentHp <= 0) handleMonsterDeath(m, gameState.monsters.indexOf(m));
                        }
                    }
                    break;
                }
                case 'ground_aoe': {
                    const targetPos = nearestEnemy ? {x: nearestEnemy.x, y: nearestEnemy.y} : {x: p.x + (Math.random() - 0.5) * 200, y: p.y + (Math.random() - 0.5) * 200};
                    createGroundAoeVFX(targetPos.x, targetPos.y, evolution.radius || weaponData.radius, 'rgba(173, 216, 230, 0.5)', evolution.duration || weaponData.duration, damage);
                    break;
                }
            }
        }
        
        function handleMonsterDeath(monster, index) {
            gameState.killCount++;
            gameState.xpOrbs.push({ x: monster.x, y: monster.y, value: monster.xp, radius: 5 });
            
            if (monster.splits) {
                const numSplits = 2;
                for (let i = 0; i < numSplits; i++) {
                    const miniSlimeData = JSON.parse(JSON.stringify(MONSTERS['mini_slime']));
                    gameState.monsters.push({
                        ...miniSlimeData,
                        x: monster.x + (Math.random() - 0.5) * 20,
                        y: monster.y + (Math.random() - 0.5) * 20,
                        speed: miniSlimeData.stats.agi * 0.2,
                        currentHp: miniSlimeData.stats.hp,
                    });
                }
            }

            if (index > -1) gameState.monsters.splice(index, 1);
        }

        function spawnBoss(bossId) {
            const monsterData = JSON.parse(JSON.stringify(MONSTERS[bossId]));
            const diff = gameState.difficulty;
            monsterData.stats.hp *= diff;
            monsterData.stats.str *= diff;

            gameState.monsters.push({
                ...monsterData,
                x: gameState.player.x + 300, y: gameState.player.y,
                speed: monsterData.stats.agi * 0.2,
                currentHp: monsterData.stats.hp,
            });
        }
        
        function levelUp() {
            const p = gameState.player;
            p.level++;
            p.xp -= p.xpToNextLevel;
            p.xpToNextLevel = Math.floor(p.xpToNextLevel * 1.2);
            
            gameState.isPaused = true;
            playSound('levelUp');
            showLevelUpModal();

            recalculatePlayerStats();
            p.currentHp = p.effectiveStats.hp;
            playLevelUpEffect();
        }
        
        function gameOver() {
            gameState.isPaused = true;
            gameState.isGameOver = true;
            DOMElements.gameOverModal.innerHTML = `<div class="modal-panel text-center">
                <h1 class="modal-title text-2xl text-red-500">게임 오버</h1>
                <p class="mb-6 text-gray-400">당신은 ${gameState.stage + 1} 스테이지에서 ${gameState.killCount}마리의 적을 처치했습니다.</p>
                <button id="restart-game-btn" class="game-button text-base py-2 px-8">다시 시작</button>
            </div>`;
            DOMElements.gameOverModal.classList.remove('hidden');
            document.getElementById('restart-game-btn').addEventListener('click', () => {
                DOMElements.gameOverModal.classList.add('hidden');
                document.location.reload();
            });
        }
        
        // --- VFX FACTORY ---
        function createLineVFX(startX, startY, endX, endY, color, width, duration) {
            const vfx = {
                type: 'chain', startX, startY, endX, endY, color, width,
                opacity: 1, x: (startX + endX) / 2, y: (startY + endY) / 2,
                destroyTime: Date.now() + duration,
                update: function() { this.opacity = (this.destroyTime - Date.now()) / duration; }
            };
            gameState.vfx.push(vfx);
        }

        function createExpandingRingVFX(x, y, maxRadius, color, duration) {
            const vfx = {
                type: 'ring', x, y, radius: 0, color,
                opacity: 1,
                destroyTime: Date.now() + duration,
                update: function() {
                    const progress = (this.destroyTime - Date.now()) / duration;
                    this.radius = maxRadius * (1 - progress);
                    this.opacity = progress;
                }
            };
            gameState.vfx.push(vfx);
        }
        
        function createGroundAoeVFX(x, y, radius, color, duration, damage) {
            const vfx = {
                type: 'ground_aoe', x, y, radius, color,
                opacity: 0.5,
                damage: damage,
                lastTick: 0,
                tickRate: 500, // Damage every 0.5s
                destroyTime: Date.now() + duration,
                update: function(now) {
                    if (now > this.lastTick + this.tickRate) {
                        this.lastTick = now;
                        for (const m of gameState.monsters) {
                            if (Math.hypot(this.x - m.x, this.y - m.y) < this.radius) {
                                m.currentHp -= this.damage;
                                createDamageText(m, this.damage, this.color);
                                if (m.currentHp <= 0) handleMonsterDeath(m, gameState.monsters.indexOf(m));
                            }
                        }
                    }
                    this.opacity = 0.3 + Math.sin((now / 200)) * 0.2; // Pulsing effect
                }
            };
            gameState.vfx.push(vfx);
        }

        function createDamageText(entity, amount, color) {
            const textEl = document.createElement('div');
            textEl.className = 'damage-text';
            textEl.textContent = Math.floor(amount);
            textEl.style.color = color;
            textEl.style.left = `${entity.x - camera.x}px`;
            textEl.style.top = `${entity.y - camera.y - entity.radius}px`;
            DOMElements.vfxContainer.appendChild(textEl);
            
            anime({
                targets: textEl,
                translateY: [0, -50],
                opacity: [1, 0],
                duration: 800,
                easing: 'easeOutQuad',
                complete: () => textEl.remove()
            });
        }

        function playLevelUpEffect() {
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.background = '#D4AF37';
                particle.style.width = `${Math.random() * 5 + 2}px`;
                particle.style.height = particle.style.width;
                particle.style.borderRadius = '50%';
                particle.style.left = `${canvas.width / 2}px`;
                particle.style.top = `${canvas.height / 2}px`;
                DOMElements.vfxContainer.appendChild(particle);

                anime({
                    targets: particle,
                    translateX: anime.random(-150, 150),
                    translateY: anime.random(-150, 150),
                    opacity: [1, 0],
                    duration: 1000,
                    easing: 'easeOutExpo',
                    complete: () => particle.remove()
                });
            }
        }
        
        // --- UI & CONTROLS ---
        function setupEventListeners() {
            document.getElementById('start-game-btn').addEventListener('click', async () => {
                await Tone.start();
                setupSounds();
                DOMElements.introScreen.classList.add('hidden');
                renderHeroSelection();
                DOMElements.heroSelection.classList.remove('hidden');
            });

            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.clientX < window.innerWidth / 2) {
                        if (moveJoystick.touchId === null) {
                            moveJoystick.touchId = touch.identifier;
                            moveJoystick.startX = touch.clientX;
                            moveJoystick.startY = touch.clientY;
                            DOMElements.joystickArea.style.left = `${touch.clientX}px`;
                            DOMElements.joystickArea.style.top = `${touch.clientY}px`;
                            DOMElements.joystickArea.style.transform = `translate(-50%, -50%)`;
                            DOMElements.joystickArea.style.opacity = '1';
                        }
                    } else {
                        if (skillJoystick.touchId === null) {
                            skillJoystick.touchId = touch.identifier;
                            skillJoystick.startX = touch.clientX;
                            skillJoystick.startY = touch.clientY;
                            DOMElements.skillJoystickArea.style.left = `${touch.clientX}px`;
                            DOMElements.skillJoystickArea.style.top = `${touch.clientY}px`;
                            DOMElements.skillJoystickArea.style.transform = `translate(-50%, -50%)`;
                            DOMElements.skillJoystickArea.style.opacity = '1';
                        }
                    }
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.identifier === moveJoystick.touchId) {
                        const dx = touch.clientX - moveJoystick.startX;
                        const dy = touch.clientY - moveJoystick.startY;
                        const dist = Math.hypot(dx, dy);
                        moveJoystick.active = true;
                        if (dist > 0) {
                            moveJoystick.dx = dx / dist;
                            moveJoystick.dy = dy / dist;
                        }
                        const stickMaxDist = 50;
                        const stickClamped = Math.min(dist, stickMaxDist);
                        const stickX = (dx / dist) * stickClamped;
                        const stickY = (dy / dist) * stickClamped;
                        DOMElements.joystickStick.style.transform = `translate(-50%, -50%) translate(${stickX}px, ${stickY}px)`;
                    } else if (touch.identifier === skillJoystick.touchId) {
                        const dx = touch.clientX - skillJoystick.startX;
                        const dy = touch.clientY - skillJoystick.startY;
                        const dist = Math.hypot(dx, dy);
                        skillJoystick.active = true;
                        skillJoystick.angle = Math.atan2(dy, dx);
                        const maxDist = 50;
                        const clampedDist = Math.min(dist, maxDist);
                        skillJoystick.intensity = clampedDist / maxDist;
                        const stickX = (dx / dist) * clampedDist;
                        const stickY = (dy / dist) * clampedDist;
                        DOMElements.skillJoystickStick.style.transform = `translate(-50%, -50%) translate(${stickX}px, ${stickY}px)`;
                    }
                }
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                for (const touch of e.changedTouches) {
                    if (touch.identifier === moveJoystick.touchId) {
                        moveJoystick.active = false;
                        moveJoystick.touchId = null;
                        moveJoystick.dx = 0;
                        moveJoystick.dy = 0;
                        DOMElements.joystickArea.style.opacity = '0';
                        DOMElements.joystickStick.style.transform = 'translate(-50%, -50%)';
                    } else if (touch.identifier === skillJoystick.touchId) {
                        throwGrenade(skillJoystick.angle, skillJoystick.intensity);
                        skillJoystick.active = false;
                        skillJoystick.touchId = null;
                        skillJoystick.intensity = 0;
                        DOMElements.skillJoystickArea.style.opacity = '0';
                        DOMElements.skillJoystickStick.style.transform = 'translate(-50%, -50%)';
                    }
                }
            }, { passive: false });
        }
        
        function throwGrenade(angle, intensity) {
            const p = gameState.player;
            const now = Date.now();
            if (!p || now < p.grenade.lastUsed + p.grenade.cooldown || intensity < 0.1) return;

            p.grenade.lastUsed = now;
            playSound('throw');

            const currentThrowRange = p.grenade.throwRange * intensity;
            const targetX = p.x + Math.cos(angle) * currentThrowRange;
            const targetY = p.y + Math.sin(angle) * currentThrowRange;
            
            createExpandingRingVFX(targetX, targetY, p.grenade.blastRadius, 'rgba(255, 100, 100, 0.5)', p.grenade.fuse);

            setTimeout(() => {
                detonateGrenade(targetX, targetY);
            }, p.grenade.fuse);
        }
        
        function detonateGrenade(x, y) {
            const p = gameState.player;
            playSound('explosion');
            createExpandingRingVFX(x, y, p.grenade.blastRadius, 'rgba(255, 150, 0, 0.8)', 400);

            const damage = Math.floor(p.effectiveStats.str * p.grenade.power * p.statBonuses.power);
            gameState.monsters.forEach(m => {
                if (Math.hypot(x - m.x, y - m.y) < p.grenade.blastRadius) {
                    m.currentHp -= damage;
                    createDamageText(m, damage, '#ff9900');
                    if (m.currentHp <= 0) handleMonsterDeath(m, gameState.monsters.indexOf(m));
                }
            });
        }

        function renderHeroSelection() {
            const container = DOMElements.heroSelection;
            container.innerHTML = `<div class="modal-panel text-center">
                <h2 class="modal-title">영웅을 선택하십시오</h2>
                <div id="hero-cards-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            </div>`;
            const cardContainer = document.getElementById('hero-cards-container');
            for (const id in HEROES) {
                const hero = HEROES[id];
                const card = document.createElement('div');
                const description = id === 'kaelan' 
                    ? '높은 체력과 힘을 가진 근접 전사입니다. 안정적인 플레이에 적합합니다.' 
                    : '민첩함이 특기인 원거리 딜러입니다. 빠른 공격 속도를 자랑합니다.';

                card.className = 'p-4 border-2 border-gray-700 rounded-lg hover:border-yellow-500 cursor-pointer flex flex-col justify-between text-center';
                card.innerHTML = `
                    <div>
                        <div class="w-full h-24 bg-gray-900 rounded-md mb-4 flex items-center justify-center">
                           <p class="text-gray-500">[${hero.name} 이미지]</p>
                        </div>
                        <h3 class="font-cinzel text-lg text-yellow-400">${hero.name}</h3>
                        <p class="text-xs text-gray-400 mt-2 h-12">${description}</p>
                    </div>
                    <div class="text-sm text-gray-200 mt-4 border-t border-gray-600 pt-2 grid grid-cols-4 gap-1 text-center">
                        <span class="text-red-400">HP: ${hero.baseStats.hp}</span>
                        <span class="text-orange-400">STR: ${hero.baseStats.str}</span>
                        <span class="text-green-400">VIT: ${hero.baseStats.vit}</span>
                        <span class="text-blue-400">AGI: ${hero.baseStats.agi}</span>
                    </div>`;
                card.addEventListener('click', () => startGame(id));
                cardContainer.appendChild(card);
            }
        }

        function updateUI() {
            if (!gameState.player) return;
            const p = gameState.player;
            DOMElements.healthOrbFill.style.height = `${(p.currentHp / p.effectiveStats.hp) * 100}%`;
            DOMElements.healthOrbText.textContent = `${Math.ceil(p.currentHp)}`;
            DOMElements.xpBar.style.width = `${(p.xp / p.xpToNextLevel) * 100}%`;
            DOMElements.levelText.textContent = `LV. ${p.level}`;
            
            const now = Date.now();
            const cooldownProgress = Math.min(1, (now - p.grenade.lastUsed) / p.grenade.cooldown);
            DOMElements.skillCooldownOverlay.style.clipPath = `inset(${100 - cooldownProgress * 100}% 0 0 0)`;

            const currentStageData = STAGES[gameState.stage];
            if(currentStageData) {
                if (currentStageData.boss) {
                    const boss = gameState.monsters.find(m => m.name === MONSTERS[currentStageData.boss].name);
                    if (boss) {
                        DOMElements.stageProgress.style.width = `${(boss.currentHp / boss.stats.hp) * 100}%`;
                        DOMElements.stageText.textContent = `${boss.name.toUpperCase()}`;
                    }
                } else if (isFinite(currentStageData.duration)) {
                    const elapsedTime = (now - gameState.stageStartTime) / 1000;
                    DOMElements.stageProgress.style.width = `${(elapsedTime / currentStageData.duration) * 100}%`;
                    DOMElements.stageText.textContent = `STAGE ${gameState.stage + 1}`;
                } else {
                    DOMElements.stageProgress.style.width = `100%`;
                    DOMElements.stageText.textContent = `무한 모드`;
                }
            }
        }
        
        function showLevelUpModal() {
            const p = gameState.player;
            const choices = [];
            
            const allWeaponsMaxed = p.activeWeapons.every(w => w.level >= WEAPONS[w.id].maxLevel);

            if (allWeaponsMaxed && p.activeWeapons.length >= 4) {
                // Offer stat upgrades
                const statUpgrades = [
                    { type: 'hp', text: '최대 체력 +10%', value: 0.1 },
                    { type: 'power', text: '공격력 +5%', value: 0.05 },
                    { type: 'speed', text: '이동 속도 +5%', value: 0.05 }
                ];
                // Shuffle and pick 3
                for (let i = statUpgrades.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [statUpgrades[i], statUpgrades[j]] = [statUpgrades[j], statUpgrades[i]];
                }
                choices.push(...statUpgrades.slice(0, 3));
            } else {
                // Offer weapon upgrades
                const existingWeapons = p.activeWeapons.map(w => w.id);
                const newWeaponPool = UPGRADE_POOL.filter(wId => !existingWeapons.includes(wId));
                
                let upgradeOptions = [];
                p.activeWeapons.forEach(w => {
                    const weaponData = WEAPONS[w.id];
                    if (w.level < weaponData.maxLevel) {
                        upgradeOptions.push({ id: w.id, level: w.level, isNew: false });
                    }
                });
                if (newWeaponPool.length > 0 && p.activeWeapons.length < 6) {
                    newWeaponPool.forEach(wId => {
                        upgradeOptions.push({ id: wId, level: 0, isNew: true });
                    });
                }

                while(choices.length < 3 && upgradeOptions.length > 0) {
                    const randIndex = Math.floor(Math.random() * upgradeOptions.length);
                    choices.push(upgradeOptions.splice(randIndex, 1)[0]);
                }
            }

            DOMElements.levelUpModal.innerHTML = `<div class="modal-panel">
                <h2 class="modal-title">레벨 업!</h2>
                <div class="grid grid-cols-1 gap-4">
                    ${choices.map(c => {
                        if (c.type) { // Stat upgrade
                            return `<div class="upgrade-card" data-type="stat" data-stat="${c.type}" data-value="${c.value}">
                                 <h3 class="font-bold text-lg text-green-400">${c.text}</h3>
                                 <p class="text-sm text-gray-400">영구적인 능력치 강화</p>
                             </div>`;
                        } else { // Weapon upgrade
                            const weaponData = WEAPONS[c.id];
                            if (c.isNew) {
                                return `<div class="upgrade-card" data-type="new" data-id="${c.id}">
                                    <h3 class="font-bold text-lg text-green-400">새 무기: ${weaponData.name}</h3>
                                    <p class="text-sm text-gray-400">${weaponData.description}</p>
                                </div>`;
                            } else {
                                const nextLevel = c.level + 1;
                                const evolution = weaponData.evolution.find(e => e.level === nextLevel);
                                return `<div class="upgrade-card" data-type="upgrade" data-id="${c.id}">
                                    <h3 class="font-bold text-lg text-yellow-400">${weaponData.name} 강화</h3>
                                    <p class="text-sm text-gray-400">Lv. ${c.level} -> Lv. ${nextLevel}</p>
                                    ${evolution ? `<p class="text-sm text-cyan-400 mt-2">${evolution.description}</p>` : ''}
                                </div>`;
                            }
                        }
                    }).join('')}
                </div>
            </div>`;
            DOMElements.levelUpModal.classList.remove('hidden');
            DOMElements.levelUpModal.querySelectorAll('.upgrade-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    const choiceType = e.currentTarget.dataset.type;
                    if (choiceType === 'stat') {
                        const stat = e.currentTarget.dataset.stat;
                        const value = parseFloat(e.currentTarget.dataset.value);
                        p.statBonuses[stat] += value;
                    } else {
                        const weaponId = e.currentTarget.dataset.id;
                        if (choiceType === 'new') {
                            p.activeWeapons.push({ id: weaponId, level: 1, lastFired: 0 });
                        } else {
                            const weaponToUpgrade = p.activeWeapons.find(w => w.id === weaponId);
                            if(weaponToUpgrade) weaponToUpgrade.level++;
                        }
                    }
                    recalculatePlayerStats();
                    DOMElements.levelUpModal.classList.add('hidden');
                    gameState.isPaused = false;
                });
            });
        }
        
        // --- INITIALIZE ---
        window.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
