<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>크로노사인: 서바이버</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Noto+Sans+KR:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --dark-bg: #000000;
            --panel-bg: rgba(10, 10, 10, 0.9);
            --border-color: #5a4a3a;
            --gold-color: #D4AF37;
            --red-color: #a01c1c;
            --xp-color: #6d28d9;
        }
        body, html { 
            font-family: 'Noto Sans KR', sans-serif; 
            background-color: var(--dark-bg); 
            color: #c7c7c7; 
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }
        .font-cinzel { font-family: 'Cinzel', serif; }
        .hidden { display: none !important; }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: crosshair;
        }

        /* UI Elements */
        #top-ui {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 500px;
            pointer-events: none;
        }
        #stage-progress-bar-bg {
            background-color: #222;
            border: 2px solid var(--border-color);
            padding: 2px;
            border-radius: 5px;
        }
        #stage-progress-bar {
            height: 15px;
            background: linear-gradient(to right, #fde047, #f59e0b);
            width: 0%;
            transition: width 0.3s;
            border-radius: 2px;
        }
        #stage-text {
            text-align: center;
            color: white;
            font-family: 'Cinzel', serif;
            margin-top: 4px;
            text-shadow: 1px 1px 2px black;
        }

        #game-ui-bottom {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: flex-end;
            pointer-events: none;
        }
        #xp-bar-bg {
            width: 60%;
            max-width: 400px;
            height: 12px;
            background-color: #222;
            border: 2px solid var(--border-color);
            border-radius: 6px;
            margin-bottom: 10px;
        }
        #xp-bar {
            height: 100%;
            background: linear-gradient(to right, #8b5cf6, #a78bfa);
            width: 0%;
            transition: width 0.3s;
            border-radius: 4px;
        }
        #level-text {
            position: absolute;
            bottom: 25px;
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
        }
        
        .orb {
            position: fixed;
            bottom: 10px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background-color: #000;
            border: 4px solid #4a4a4a;
            overflow: hidden;
        }
        #health-orb { left: 10px; }
        
        .orb-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            width: 100%;
            background-color: var(--red-color);
            transition: height 0.2s;
        }
        .orb-text {
            position: absolute;
            bottom: 5px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-family: 'Cinzel', serif;
            font-size: 0.9rem;
            text-shadow: 1px 1px 2px black;
        }

        /* Modal Windows */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
        }
        .modal-panel {
            background-color: var(--panel-bg);
            border: 3px solid var(--border-color);
            box-shadow: 0 0 20px black;
            padding: 1.5rem;
            width: 90%;
            max-width: 600px;
            border-radius: 8px;
        }
        .modal-title {
            font-family: 'Cinzel', serif;
            color: var(--gold-color);
            text-align: center;
            font-size: 1.5rem;
            margin-bottom: 1.5rem;
        }
        .upgrade-card {
            background-color: #1a1a1a;
            border: 2px solid var(--border-color);
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            border-radius: 6px;
        }
        .upgrade-card:hover {
            border-color: var(--gold-color);
            transform: translateY(-5px);
        }
        
        .game-button {
            background: linear-gradient(to bottom, #a37d2a, #825e1a);
            border: 2px solid #5a4a3a;
            color: white;
            font-family: 'Cinzel', serif;
            border-radius: 5px;
            text-shadow: 1px 1px 2px black;
            transition: all 0.2s;
            box-shadow: 0 4px #4d3c28;
        }
        .game-button:hover {
            background: linear-gradient(to bottom, #b88d30, #966c1e);
            transform: translateY(-2px);
            box-shadow: 0 6px #4d3c28;
        }
        .game-button:active {
            transform: translateY(2px);
            box-shadow: 0 2px #4d3c28;
        }


        /* Mobile Controls */
        #joystick-area, #skill-joystick-area {
            position: fixed;
            bottom: 20px;
            width: 150px;
            height: 150px;
            z-index: 50;
        }
        #joystick-area { left: 20px; }
        #skill-joystick-area { right: 20px; }

        .control-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(0,0,0,0.3);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            border: 2px solid rgba(255,255,255,0.2);
        }
        .control-stick {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.4);
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        #skill-cooldown-overlay {
            position: absolute;
            width: 120px;
            height: 120px;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.6);
            clip-path: inset(100% 0 0 0);
            transition: clip-path 0.1s linear;
        }
        
        /* VFX */
        .damage-text {
            position: absolute;
            font-family: 'Cinzel', serif;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            z-index: 150;
        }
        #player-hit-overlay {
            position: fixed;
            inset: 0;
            background-color: rgba(255, 0, 0, 0.5);
            opacity: 0;
            pointer-events: none;
            z-index: 200;
        }
        #notification-panel {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: none;
            z-index: 201;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .notification {
            background-color: var(--panel-bg);
            color: var(--gold-color);
            padding: 10px 20px;
            border-radius: 5px;
            border: 2px solid var(--border-color);
            font-family: 'Cinzel', serif;
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="game-canvas" tabindex="1"></canvas>
        <div id="vfx-container"></div>
        <div id="player-hit-overlay"></div>
        <div id="notification-panel"></div>
        
        <div id="top-ui" class="hidden">
            <div id="stage-progress-bar-bg">
                <div id="stage-progress-bar"></div>
            </div>
            <p id="stage-text">STAGE 1</p>
        </div>

        <div id="game-ui-bottom" class="hidden">
            <div id="xp-bar-bg">
                <div id="xp-bar"></div>
            </div>
            <p id="level-text">LV. 1</p>
        </div>
        
        <div id="health-orb" class="orb hidden">
            <div id="health-orb-fill" class="orb-fill"></div>
            <div id="health-orb-text" class="orb-text"></div>
        </div>
        
        <div id="joystick-area" class="hidden">
            <div class="control-base"></div>
            <div id="joystick-stick" class="control-stick"></div>
        </div>
        <div id="skill-joystick-area" class="hidden">
            <div class="control-base">
                <div id="skill-cooldown-overlay"></div>
            </div>
            <div id="skill-joystick-stick" class="control-stick"></div>
        </div>
        
        <div id="modals-container">
            <div id="intro-screen" class="modal-overlay">
                <div class="modal-panel text-center">
                    <h1 class="modal-title text-2xl">크로노사인: 서바이버</h1>
                    <p class="mb-6 text-gray-400">시간의 균열이 열리고, 모든 시대의 괴물들이 쏟아져 나옵니다. 당신은 이 혼돈 속에서 살아남아야 하는 유일한 희망입니다. 끊임없이 몰려오는 적들을 처치하고, 힘을 키워 균열의 근원을 파괴하십시오.</p>
                    <button id="start-game-btn" class="game-button text-base py-2 px-8">게임 시작</button>
                </div>
            </div>
            <div id="hero-selection-screen" class="modal-overlay hidden"></div>
            <div id="level-up-modal" class="modal-overlay hidden"></div>
            <div id="game-over-modal" class="modal-overlay hidden"></div>
        </div>
    </div>

    <script type="module">
        // --- GAME DATA ---
        const HEROES = {
            kaelan: { name: "카엘란", baseStats: { hp: 120, str: 15, vit: 12, agi: 8 } },
            lyra: { name: "라이라", baseStats: { hp: 80, str: 8, vit: 7, agi: 15 } },
        };
        const WEAPONS = {
            magic_missile: { 
                name: "매직 미사일", type: 'projectile', power: 1.0, speed: 7, size: 5, cooldown: 500,
                description: "가장 가까운 적에게 미사일을 발사합니다.",
                evolution: [
                    { level: 2, projectiles: 2, description: "발사체 2개로 증가" }, 
                    { level: 3, projectiles: 4, description: "발사체 4개로 증가" }, 
                    { level: 4, power: 1.5, size: 7, description: "공격력 및 크기 증가" },
                ]
            },
            chain_lightning: {
                name: "체인 라이트닝", type: 'chain', power: 0.8, cooldown: 2000, chains: 3, range: 150,
                description: "적에게 튕기는 번개를 발사합니다.",
                evolution: [ { level: 2, chains: 5, description: "최대 5번 연쇄" }, { level: 3, power: 1.2, description: "공격력 증가" }, { level: 4, chains: 7, range: 200, description: "최대 7번 연쇄, 범위 증가" } ]
            },
            fire_pulse: {
                name: "화염 파동", type: 'pulse_aura', power: 0.3, cooldown: 2500, radius: 120,
                description: "주기적으로 주변에 화염 파동을 방출하여 피해를 줍니다.",
                evolution: [ { level: 2, radius: 150, description: "범위 증가" }, { level: 3, power: 0.5, description: "공격력 증가" }, { level: 4, cooldown: 2000, description: "쿨타임 감소" } ]
            },
            ice_shards: {
                name: "얼음 파편", type: 'projectile', power: 0.7, speed: 6, size: 4, cooldown: 1500, projectiles: 8, is360: true,
                description: "모든 방향으로 얼음 파편을 발사합니다.",
                evolution: [ { level: 2, projectiles: 12, description: "파편 12개로 증가" }, { level: 3, power: 1.0, description: "공격력 증가" }, { level: 4, projectiles: 16, description: "파편 16개로 증가" } ]
            }
        };
        const MONSTERS = {
            goblin: { name: "고블린", stats: { hp: 80, str: 12, vit: 5, agi: 5 }, xp: 25, radius: 12, color: '#964B00' },
            bat: { name: "박쥐", stats: { hp: 50, str: 8, vit: 2, agi: 8 }, xp: 15, radius: 10, color: '#4B0082' },
            ogre: { name: "오우거", stats: { hp: 250, str: 25, vit: 10, agi: 3 }, xp: 50, radius: 20, color: '#808080' },
            cyclops: { name: "사이클롭스", stats: { hp: 1000, str: 40, vit: 15, agi: 2 }, xp: 200, radius: 30, color: '#D2691E' }
        };
        const STAGES = [
            { killsToAdvance: 20, monsterTypes: ['goblin'] },
            { killsToAdvance: 30, monsterTypes: ['goblin', 'bat'] },
            { killsToAdvance: 1, monsterTypes: ['goblin', 'bat', 'ogre'], boss: 'cyclops' },
        ];
        const UPGRADE_POOL = ['chain_lightning', 'fire_pulse', 'ice_shards'];

        // --- GAME STATE & SETUP ---
        let gameState = {};
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        let camera = { x: 0, y: 0 };
        let moveJoystick = { active: false, angle: 0, intensity: 0 };
        let skillJoystick = { active: false, angle: 0, intensity: 0 };
        const keys = {};
        const MAP_SIZE = { width: 3000, height: 3000 };
        let sounds = {};
        let animationFrameId;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // --- DOM ELEMENTS ---
        const DOMElements = {
            introScreen: document.getElementById('intro-screen'),
            heroSelection: document.getElementById('hero-selection-screen'),
            levelUpModal: document.getElementById('level-up-modal'),
            gameOverModal: document.getElementById('game-over-modal'),
            healthOrb: document.getElementById('health-orb'),
            healthOrbFill: document.getElementById('health-orb-fill'),
            healthOrbText: document.getElementById('health-orb-text'),
            xpBar: document.getElementById('xp-bar'),
            levelText: document.getElementById('level-text'),
            stageProgress: document.getElementById('stage-progress-bar'),
            stageText: document.getElementById('stage-text'),
            joystickArea: document.getElementById('joystick-area'),
            skillJoystickArea: document.getElementById('skill-joystick-area'),
            skillCooldownOverlay: document.getElementById('skill-cooldown-overlay'),
            topUI: document.getElementById('top-ui'),
            bottomUI: document.getElementById('game-ui-bottom'),
            vfxContainer: document.getElementById('vfx-container'),
        };

        // --- CORE FUNCTIONS ---
        function init() {
            setupEventListeners();
        }

        function startGame(heroId) {
            const heroData = HEROES[heroId];
            gameState = {
                player: {
                    ...heroData,
                    x: MAP_SIZE.width / 2, y: MAP_SIZE.height / 2,
                    radius: 15, speed: 3,
                    level: 1, xp: 0, xpToNextLevel: 50,
                    activeWeapons: [{ id: 'magic_missile', level: 1, lastFired: 0 }],
                    invincibleUntil: 0,
                    attackRange: 0,
                    grenade: {
                        cooldown: 8000,
                        lastUsed: -8000,
                        throwRange: 200,
                        blastRadius: 100,
                        power: 2.5,
                        fuse: 1500,
                    },
                },
                monsters: [],
                xpOrbs: [],
                projectiles: [],
                vfx: [],
                stage: 0,
                killCount: 0,
                isPaused: false,
                isGameOver: false,
            };
            recalculatePlayerStats();
            DOMElements.heroSelection.classList.add('hidden');
            
            DOMElements.topUI.classList.remove('hidden');
            DOMElements.bottomUI.classList.remove('hidden');
            DOMElements.healthOrb.classList.remove('hidden');
            DOMElements.joystickArea.classList.remove('hidden');
            DOMElements.skillJoystickArea.classList.remove('hidden');
            
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
        }
        
        function recalculatePlayerStats() {
            const p = gameState.player;
            p.effectiveStats = { ...p.baseStats };
            p.effectiveStats.hp = p.baseStats.hp + (p.effectiveStats.vit * 10);
            if (p.currentHp === undefined || p.currentHp > p.effectiveStats.hp) p.currentHp = p.effectiveStats.hp;
            
            p.attackRange = 0;
            p.activeWeapons.forEach(w => {
                const weaponData = WEAPONS[w.id];
                if (weaponData.range || weaponData.type === 'pulse_aura') {
                    const evolutionLevels = weaponData.evolution.filter(e => w.level >= e.level);
                    const evolution = evolutionLevels.reduce((acc, val) => ({...acc, ...val}), {});
                    const currentRange = evolution.range || evolution.radius || weaponData.range || weaponData.radius;
                    if (currentRange > p.attackRange) p.attackRange = currentRange;
                }
            });
        }

        function spawnMonster() {
            if (!gameState.player) return;
            const currentStage = STAGES[gameState.stage];
            if (!currentStage || currentStage.bossActive) return;

            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(canvas.width, canvas.height) / 2 + 50;
            const x = gameState.player.x + Math.cos(angle) * radius;
            const y = gameState.player.y + Math.sin(angle) * radius;
            
            const monsterId = currentStage.monsterTypes[Math.floor(Math.random() * currentStage.monsterTypes.length)];
            const monsterData = JSON.parse(JSON.stringify(MONSTERS[monsterId]));
            gameState.monsters.push({
                ...monsterData, x, y,
                speed: monsterData.stats.agi * 0.2,
                currentHp: monsterData.stats.hp,
            });
        }
        
        // --- SOUND MANAGER ---
        function setupSounds() {
            sounds.shoot = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 } }).toDestination();
            sounds.hit = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.05, sustain: 0 } }).toDestination();
            sounds.xp = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
            sounds.levelUp = new Tone.PolySynth(Tone.Synth).toDestination();
            sounds.throw = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0, release: 0.1 } }).toDestination();
            sounds.explosion = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.5, sustain: 0.1, release: 0.2 } }).toDestination();
        }

        function playSound(effect, options = {}) {
            if (!sounds[effect] || Tone.context.state !== 'running') return;
            const now = Tone.now();
            switch (effect) {
                case 'shoot': sounds.shoot.triggerAttackRelease('C5', '16n', now); break;
                case 'hit': sounds.hit.triggerAttackRelease('8n', now); break;
                case 'xp': sounds.xp.triggerAttackRelease(options.note || 'A5', '16n', now); break;
                case 'levelUp': sounds.levelUp.triggerAttackRelease(['C4', 'E4', 'G4', 'C5'], '8n', now); break;
                case 'throw': sounds.throw.triggerAttackRelease('G4', '8n', now); break;
                case 'explosion': sounds.explosion.triggerAttackRelease('2n', now); break;
            }
        }
        
        // --- GAME LOOP & DRAWING ---
        let lastSpawnTime = 0;
        function gameLoop() {
            if (gameState.isGameOver) return;

            const now = Date.now();
            if (!gameState.isPaused) {
                update(now);
                if (now - lastSpawnTime > (1000 - gameState.stage * 100)) {
                    spawnMonster();
                    lastSpawnTime = now;
                }
            }
            draw();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        function update(now) {
            updatePlayer(now);
            updateMonsters(now);
            updateProjectiles();
            updateXpOrbs();
            updateVFX(now);
        }

        function draw() {
            if (!gameState.player) return;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            camera.x = gameState.player.x - canvas.width / 2;
            camera.y = gameState.player.y - canvas.height / 2;

            drawMap();
            drawXpOrbs();
            drawProjectiles();
            drawVFX();
            drawMonsters();
            drawPlayer();
            drawGrenadeTrajectory();
            updateUI();
        }

        function drawMap() {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            const gridSize = 50;
            const startX = -camera.x % gridSize;
            const startY = -camera.y % gridSize;
            
            for(let x = startX; x < canvas.width; x += gridSize) {
                ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
            }
            for(let y = startY; y < canvas.height; y += gridSize) {
                ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
            }
        }

        function drawCharacter(char) {
            const gradient = ctx.createRadialGradient(
                char.x - camera.x, char.y - camera.y, char.radius * 0.2,
                char.x - camera.x, char.y - camera.y, char.radius
            );
            gradient.addColorStop(0, char.color);
            gradient.addColorStop(1, 'black');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(char.x - camera.x, char.y - camera.y, char.radius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPlayer() { 
            const p = gameState.player;
            if (Date.now() < p.invincibleUntil) {
                ctx.globalAlpha = 0.5;
            }
            drawCharacter({...p, color: '#3b82f6'}); 
            ctx.globalAlpha = 1.0;
            
            if (p.attackRange > 0) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, p.attackRange, 0, Math.PI * 2);
                ctx.stroke();
            }
        }
        function drawMonsters() { gameState.monsters.forEach(m => drawCharacter(m)); }
        
        function drawXpOrbs() {
            gameState.xpOrbs.forEach(orb => {
                ctx.fillStyle = '#a78bfa';
                ctx.beginPath();
                ctx.arc(orb.x - camera.x, orb.y - camera.y, orb.radius, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawProjectiles() {
            gameState.projectiles.forEach(p => {
                ctx.fillStyle = p.color || 'white';
                ctx.beginPath();
                ctx.arc(p.x - camera.x, p.y - camera.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
        }
        
        function drawVFX() {
             gameState.vfx.forEach(v => {
                ctx.save();
                ctx.globalAlpha = v.opacity;
                if (v.type === 'chain') {
                    ctx.strokeStyle = v.color;
                    ctx.lineWidth = v.width;
                    ctx.beginPath();
                    ctx.moveTo(v.startX - camera.x, v.startY - camera.y);
                    ctx.lineTo(v.endX - camera.x, v.endY - camera.y);
                    ctx.stroke();
                } else {
                    ctx.fillStyle = v.color;
                    ctx.beginPath();
                    ctx.arc(v.x - camera.x, v.y - camera.y, v.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.restore();
            });
        }

        function drawGrenadeTrajectory() {
            if (!skillJoystick.active || !gameState.player) return;

            const p = gameState.player;
            const startX = p.x - camera.x;
            const startY = p.y - camera.y;
            
            const endX = p.x + Math.cos(skillJoystick.angle) * p.grenade.throwRange - camera.x;
            const endY = p.y + Math.sin(skillJoystick.angle) * p.grenade.throwRange - camera.y;

            ctx.save();
            ctx.setLineDash([10, 10]);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();

            // Draw landing circle
            ctx.beginPath();
            ctx.arc(endX, endY, p.grenade.blastRadius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.restore();
        }

        // --- UPDATE LOGIC ---
        function updatePlayer(now) {
            const p = gameState.player;
            let dx = 0, dy = 0;
            let speedMultiplier = 1.0;

            if (moveJoystick.active) {
                dx = Math.cos(moveJoystick.angle);
                dy = Math.sin(moveJoystick.angle);
                speedMultiplier = moveJoystick.intensity;
            } else {
                if (keys['w'] || keys['ArrowUp']) dy = -1;
                if (keys['s'] || keys['ArrowDown']) dy = 1;
                if (keys['a'] || keys['ArrowLeft']) dx = -1;
                if (keys['d'] || keys['ArrowRight']) dx = 1;
            }
            if (dx !== 0 || dy !== 0) {
                const magnitude = Math.hypot(dx, dy);
                const currentSpeed = p.speed * speedMultiplier;
                p.x += (dx / magnitude) * currentSpeed;
                p.y += (dy / magnitude) * currentSpeed;
            }
            p.x = Math.max(p.radius, Math.min(MAP_SIZE.width - p.radius, p.x));
            p.y = Math.max(p.radius, Math.min(MAP_SIZE.height - p.radius, p.y));
            
            p.activeWeapons.forEach(weapon => {
                if (now > (weapon.lastFired || 0)) {
                    handlePlayerAttack(weapon, now);
                }
            });
        }

        function updateMonsters(now) {
            const p = gameState.player;
            gameState.monsters.forEach(m => {
                const dist = Math.hypot(p.x - m.x, p.y - m.y);
                const angle = Math.atan2(p.y - m.y, p.x - m.x);
                m.x += Math.cos(angle) * m.speed;
                m.y += Math.sin(angle) * m.speed;
                
                if (dist < p.radius + m.radius && now > p.invincibleUntil) {
                    p.currentHp -= m.stats.str;
                    p.invincibleUntil = now + 500;
                    createDamageText(p, m.stats.str, '#ff4d4d');
                    anime({ targets: '#player-hit-overlay', opacity: [1, 0], duration: 300, easing: 'easeOutQuad' });
                    if (p.currentHp <= 0) gameOver();
                }
            });
        }

        function updateProjectiles() {
            for(let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const p = gameState.projectiles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.lifespan--;

                for(let j = gameState.monsters.length - 1; j >= 0; j--) {
                    const m = gameState.monsters[j];
                    if (Math.hypot(p.x - m.x, p.y - m.y) < m.radius + p.size) {
                        m.currentHp -= p.damage;
                        createDamageText(m, p.damage, 'white');
                        playSound('hit');
                        gameState.projectiles.splice(i, 1);
                        if (m.currentHp <= 0) handleMonsterDeath(m, j);
                        return;
                    }
                }
                if (p.lifespan <= 0) gameState.projectiles.splice(i, 1);
            }
        }
        
        function updateVFX(now) {
             for (let i = gameState.vfx.length - 1; i >= 0; i--) {
                const v = gameState.vfx[i];
                if (v.update) v.update();
                if (now > v.destroyTime) {
                    gameState.vfx.splice(i, 1);
                }
            }
        }

        function updateXpOrbs() {
            const p = gameState.player;
            for(let i = gameState.xpOrbs.length - 1; i >= 0; i--) {
                const orb = gameState.xpOrbs[i];
                const dist = Math.hypot(p.x - orb.x, p.y - orb.y);
                if (dist < 100) {
                    const angle = Math.atan2(p.y - orb.y, p.x - orb.x);
                    orb.x += Math.cos(angle) * 5;
                    orb.y += Math.sin(angle) * 5;
                }
                if (dist < p.radius) {
                    p.xp += orb.value;
                    playSound('xp', {note: 'C6'});
                    if (p.xp >= p.xpToNextLevel) levelUp();
                    gameState.xpOrbs.splice(i, 1);
                }
            }
        }

        function handlePlayerAttack(weaponInstance, now) {
            const p = gameState.player;
            const weaponData = WEAPONS[weaponInstance.id];
            
            const evolutionLevels = weaponData.evolution.filter(e => weaponInstance.level >= e.level);
            const evolution = evolutionLevels.reduce((acc, val) => ({...acc, ...val}), {});

            const cooldown = evolution.cooldown || weaponData.cooldown;
            weaponInstance.lastFired = now + (cooldown / (p.effectiveStats.agi * 0.1));
            const power = weaponData.power * (evolution.power || 1);
            const damage = Math.max(1, Math.floor(p.effectiveStats.str * power));

            const findNearestEnemy = (from, exclude = []) => {
                let nearest = null; let minDistance = Infinity;
                gameState.monsters.forEach(m => {
                    if (exclude.includes(m)) return;
                    const dist = Math.hypot(from.x - m.x, from.y - m.y);
                    if (dist < minDistance) {
                        minDistance = dist;
                        nearest = m;
                    }
                });
                return { enemy: nearest, distance: minDistance };
            };

            const { enemy: nearestEnemy, distance: nearestDist } = findNearestEnemy(p);
            if (!nearestEnemy && weaponData.type !== 'pulse_aura' && !weaponData.is360) return;
            
            let targetAngle = nearestEnemy ? Math.atan2(nearestEnemy.y - p.y, nearestEnemy.x - p.x) : 0;

            switch (weaponData.type) {
                case 'projectile': {
                    playSound('shoot');
                    const numProjectiles = evolution.projectiles || weaponData.projectiles || 1;
                    const angleSpread = weaponData.is360 ? (Math.PI * 2 / numProjectiles) : (evolution.angleSpread || 0.2);
                    const baseAngle = targetAngle - (angleSpread * (numProjectiles - 1)) / 2;

                    for (let i = 0; i < numProjectiles; i++) {
                        const currentAngle = weaponData.is360 ? i * angleSpread + (targetAngle * !weaponData.is360) : baseAngle + i * angleSpread;
                        gameState.projectiles.push({
                            x: p.x, y: p.y,
                            vx: Math.cos(currentAngle) * weaponData.speed,
                            vy: Math.sin(currentAngle) * weaponData.speed,
                            damage: damage,
                            size: evolution.size || weaponData.size,
                            lifespan: 100,
                            color: weaponInstance.id === 'ice_shards' ? '#60a5fa' : 'white',
                        });
                    }
                    break;
                }
                case 'chain': {
                    if (!nearestEnemy || nearestDist > (evolution.range || weaponData.range)) return;
                    
                    let currentTarget = nearestEnemy;
                    let lastTarget = p;
                    const hitEnemies = [nearestEnemy];
                    const maxChains = evolution.chains || weaponData.chains;

                    for(let i = 0; i < maxChains; i++) {
                        if (!currentTarget) break;
                        currentTarget.currentHp -= damage;
                        createDamageText(currentTarget, damage, '#facc15');
                        if (currentTarget.currentHp <= 0) handleMonsterDeath(currentTarget, gameState.monsters.indexOf(currentTarget));
                        
                        createLineVFX(lastTarget.x, lastTarget.y, currentTarget.x, currentTarget.y, '#facc15', 3, 100);
                        
                        lastTarget = currentTarget;
                        const { enemy: nextTarget } = findNearestEnemy(currentTarget, hitEnemies);
                        if (nextTarget && Math.hypot(currentTarget.x - nextTarget.x, currentTarget.y - nextTarget.y) < (evolution.range || weaponData.range)) {
                            currentTarget = nextTarget;
                            hitEnemies.push(nextTarget);
                        } else {
                            currentTarget = null;
                        }
                    }
                    break;
                }
                case 'pulse_aura': {
                    const radius = evolution.radius || weaponData.radius;
                    createExpandingRingVFX(p.x, p.y, radius, '#ff9900', 300);
                    gameState.monsters.forEach(m => {
                        if (Math.hypot(p.x - m.x, p.y - m.y) < radius) {
                            m.currentHp -= damage;
                            createDamageText(m, damage, '#ff9900');
                            if (m.currentHp <= 0) handleMonsterDeath(m, gameState.monsters.indexOf(m));
                        }
                    });
                    break;
                }
            }
        }
        
        function handleMonsterDeath(monster, index) {
            gameState.killCount++;
            gameState.xpOrbs.push({ x: monster.x, y: monster.y, value: monster.xp, radius: 5 });
            if (index > -1) gameState.monsters.splice(index, 1);
            
            const currentStage = STAGES[gameState.stage];
            if (currentStage && !currentStage.bossActive && gameState.killCount >= currentStage.killsToAdvance) {
                if(currentStage.boss) {
                    spawnBoss(currentStage.boss);
                    currentStage.bossActive = true;
                } else {
                    gameState.stage++;
                    gameState.killCount = 0;
                }
            }
        }

        function spawnBoss(bossId) {
            const monsterData = JSON.parse(JSON.stringify(MONSTERS[bossId]));
            gameState.monsters.push({
                ...monsterData,
                x: gameState.player.x + 300, y: gameState.player.y,
                speed: monsterData.stats.agi * 0.2,
                currentHp: monsterData.stats.hp,
            });
        }
        
        function levelUp() {
            const p = gameState.player;
            p.level++;
            p.xp -= p.xpToNextLevel;
            p.xpToNextLevel = Math.floor(p.xpToNextLevel * 1.2);
            
            gameState.isPaused = true;
            playSound('levelUp');
            showLevelUpModal();

            recalculatePlayerStats();
            p.currentHp = p.effectiveStats.hp;
            playLevelUpEffect();
        }
        
        function gameOver() {
            gameState.isPaused = true;
            gameState.isGameOver = true;
            DOMElements.gameOverModal.innerHTML = `<div class="modal-panel text-center">
                <h1 class="modal-title text-2xl text-red-500">게임 오버</h1>
                <p class="mb-6 text-gray-400">당신은 ${gameState.stage + 1} 스테이지에서 ${gameState.killCount}마리의 적을 처치했습니다.</p>
                <button id="restart-game-btn" class="game-button text-base py-2 px-8">다시 시작</button>
            </div>`;
            DOMElements.gameOverModal.classList.remove('hidden');
            document.getElementById('restart-game-btn').addEventListener('click', () => {
                DOMElements.gameOverModal.classList.add('hidden');
                document.location.reload();
            });
        }
        
        // --- VFX FACTORY ---
        function createLineVFX(startX, startY, endX, endY, color, width, duration) {
            const vfx = {
                type: 'chain', startX, startY, endX, endY, color, width,
                opacity: 1,
                destroyTime: Date.now() + duration,
                update: function() { this.opacity = (this.destroyTime - Date.now()) / duration; }
            };
            gameState.vfx.push(vfx);
        }

        function createExpandingRingVFX(x, y, maxRadius, color, duration) {
            const vfx = {
                type: 'ring', x, y, radius: 0, color,
                opacity: 1,
                destroyTime: Date.now() + duration,
                update: function() {
                    const progress = (this.destroyTime - Date.now()) / duration;
                    this.radius = maxRadius * (1 - progress);
                    this.opacity = progress;
                }
            };
            gameState.vfx.push(vfx);
        }

        function createDamageText(entity, amount, color) {
            const textEl = document.createElement('div');
            textEl.className = 'damage-text';
            textEl.textContent = Math.floor(amount);
            textEl.style.color = color;
            textEl.style.left = `${entity.x - camera.x}px`;
            textEl.style.top = `${entity.y - camera.y - entity.radius}px`;
            DOMElements.vfxContainer.appendChild(textEl);
            
            anime({
                targets: textEl,
                translateY: [0, -50],
                opacity: [1, 0],
                duration: 800,
                easing: 'easeOutQuad',
                complete: () => textEl.remove()
            });
        }

        function playLevelUpEffect() {
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.style.position = 'absolute';
                particle.style.background = '#D4AF37';
                particle.style.width = `${Math.random() * 5 + 2}px`;
                particle.style.height = particle.style.width;
                particle.style.borderRadius = '50%';
                particle.style.left = `${canvas.width / 2}px`;
                particle.style.top = `${canvas.height / 2}px`;
                DOMElements.vfxContainer.appendChild(particle);

                anime({
                    targets: particle,
                    translateX: anime.random(-150, 150),
                    translateY: anime.random(-150, 150),
                    opacity: [1, 0],
                    duration: 1000,
                    easing: 'easeOutExpo',
                    complete: () => particle.remove()
                });
            }
        }
        
        // --- UI & CONTROLS ---
        function setupEventListeners() {
            document.getElementById('start-game-btn').addEventListener('click', async () => {
                await Tone.start();
                setupSounds();
                DOMElements.introScreen.classList.add('hidden');
                renderHeroSelection();
                DOMElements.heroSelection.classList.remove('hidden');
            });

            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);

            function createJoystickHandler(joystickObj, stickEl) {
                return function handleTouch(e) {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const baseRect = stickEl.parentElement.parentElement.getBoundingClientRect();
                    const centerX = baseRect.left + baseRect.width / 2;
                    const centerY = baseRect.top + baseRect.height / 2;
                    const dx = touch.clientX - centerX;
                    const dy = touch.clientY - centerY;
                    
                    joystickObj.active = true;
                    joystickObj.angle = Math.atan2(dy, dx);
                    
                    const dist = Math.hypot(dx, dy);
                    const maxDist = baseRect.width / 2 - stickEl.offsetWidth / 2;
                    const clampedDist = Math.min(dist, maxDist);
                    joystickObj.intensity = clampedDist / maxDist;

                    const stickX = Math.cos(joystickObj.angle) * clampedDist;
                    const stickY = Math.sin(joystickObj.angle) * clampedDist;

                    stickEl.style.transform = `translate(-50%, -50%) translate(${stickX}px, ${stickY}px)`;
                }
            }
            
            const moveStick = document.getElementById('joystick-stick');
            const handleMove = createJoystickHandler(moveJoystick, moveStick);
            DOMElements.joystickArea.addEventListener('touchstart', handleMove, {passive: false});
            DOMElements.joystickArea.addEventListener('touchmove', handleMove, {passive: false});
            DOMElements.joystickArea.addEventListener('touchend', (e) => {
                e.preventDefault();
                moveJoystick.active = false;
                moveJoystick.intensity = 0;
                moveStick.style.transform = 'translate(-50%, -50%)';
            });

            const skillStick = document.getElementById('skill-joystick-stick');
            const handleSkill = createJoystickHandler(skillJoystick, skillStick);
            DOMElements.skillJoystickArea.addEventListener('touchstart', handleSkill, {passive: false});
            DOMElements.skillJoystickArea.addEventListener('touchmove', handleSkill, {passive: false});
            DOMElements.skillJoystickArea.addEventListener('touchend', (e) => {
                e.preventDefault();
                throwGrenade(skillJoystick.angle);
                skillJoystick.active = false;
                skillStick.style.transform = 'translate(-50%, -50%)';
            });
        }
        
        function throwGrenade(angle) {
            const p = gameState.player;
            const now = Date.now();
            if (!p || now < p.grenade.lastUsed + p.grenade.cooldown) return;

            p.grenade.lastUsed = now;
            playSound('throw');

            const targetX = p.x + Math.cos(angle) * p.grenade.throwRange;
            const targetY = p.y + Math.sin(angle) * p.grenade.throwRange;
            
            // Landing indicator
            createExpandingRingVFX(targetX, targetY, p.grenade.blastRadius, 'rgba(255, 100, 100, 0.5)', p.grenade.fuse);

            setTimeout(() => {
                detonateGrenade(targetX, targetY);
            }, p.grenade.fuse);
        }
        
        function detonateGrenade(x, y) {
            const p = gameState.player;
            playSound('explosion');
            createExpandingRingVFX(x, y, p.grenade.blastRadius, 'rgba(255, 150, 0, 0.8)', 400);

            const damage = Math.floor(p.effectiveStats.str * p.grenade.power);
            gameState.monsters.forEach(m => {
                if (Math.hypot(x - m.x, y - m.y) < p.grenade.blastRadius) {
                    m.currentHp -= damage;
                    createDamageText(m, damage, '#ff9900');
                    if (m.currentHp <= 0) handleMonsterDeath(m, gameState.monsters.indexOf(m));
                }
            });
        }

        function renderHeroSelection() {
            const container = DOMElements.heroSelection;
            container.innerHTML = `<div class="modal-panel text-center">
                <h2 class="modal-title">영웅을 선택하십시오</h2>
                <div id="hero-cards-container" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            </div>`;
            const cardContainer = document.getElementById('hero-cards-container');
            for (const id in HEROES) {
                const hero = HEROES[id];
                const card = document.createElement('div');
                const description = id === 'kaelan' 
                    ? '높은 체력과 힘을 가진 근접 전사입니다. 안정적인 플레이에 적합합니다.' 
                    : '민첩함이 특기인 원거리 딜러입니다. 빠른 공격 속도를 자랑합니다.';

                card.className = 'p-4 border-2 border-gray-700 rounded-lg hover:border-yellow-500 cursor-pointer flex flex-col justify-between text-center';
                card.innerHTML = `
                    <div>
                        <div class="w-full h-24 bg-gray-900 rounded-md mb-4 flex items-center justify-center">
                           <p class="text-gray-500">[${hero.name} 이미지]</p>
                        </div>
                        <h3 class="font-cinzel text-lg text-yellow-400">${hero.name}</h3>
                        <p class="text-xs text-gray-400 mt-2 h-12">${description}</p>
                    </div>
                    <div class="text-sm text-gray-200 mt-4 border-t border-gray-600 pt-2 grid grid-cols-4 gap-1 text-center">
                        <span class="text-red-400">HP: ${hero.baseStats.hp}</span>
                        <span class="text-orange-400">STR: ${hero.baseStats.str}</span>
                        <span class="text-green-400">VIT: ${hero.baseStats.vit}</span>
                        <span class="text-blue-400">AGI: ${hero.baseStats.agi}</span>
                    </div>`;
                card.addEventListener('click', () => startGame(id));
                cardContainer.appendChild(card);
            }
        }

        function updateUI() {
            if (!gameState.player) return;
            const p = gameState.player;
            DOMElements.healthOrbFill.style.height = `${(p.currentHp / p.effectiveStats.hp) * 100}%`;
            DOMElements.healthOrbText.textContent = `${Math.ceil(p.currentHp)}`;
            DOMElements.xpBar.style.width = `${(p.xp / p.xpToNextLevel) * 100}%`;
            DOMElements.levelText.textContent = `LV. ${p.level}`;
            
            const now = Date.now();
            const cooldownProgress = Math.min(1, (now - p.grenade.lastUsed) / p.grenade.cooldown);
            DOMElements.skillCooldownOverlay.style.clipPath = `inset(${100 - cooldownProgress * 100}% 0 0 0)`;

            const currentStage = STAGES[gameState.stage];
            if(currentStage) {
                const kills = currentStage.bossActive ? currentStage.killsToAdvance : gameState.killCount;
                DOMElements.stageProgress.style.width = `${(kills / currentStage.killsToAdvance) * 100}%`;
                DOMElements.stageText.textContent = `STAGE ${gameState.stage + 1}`;
            }
        }
        
        function showLevelUpModal() {
            const p = gameState.player;
            const choices = [];
            const existingWeapons = p.activeWeapons.map(w => w.id);
            const newWeaponPool = UPGRADE_POOL.filter(wId => !existingWeapons.includes(wId));
            
            let upgradeOptions = [];
            p.activeWeapons.forEach(w => {
                const weaponData = WEAPONS[w.id];
                const maxLevel = weaponData.evolution.length > 0 ? Math.max(...weaponData.evolution.map(e => e.level)) : 1;
                if (w.level < maxLevel) {
                    upgradeOptions.push({ id: w.id, level: w.level, isNew: false });
                }
            });
            if (newWeaponPool.length > 0 && p.activeWeapons.length < 6) {
                 newWeaponPool.forEach(wId => {
                     upgradeOptions.push({ id: wId, level: 0, isNew: true });
                 });
            }

            while(choices.length < 3 && upgradeOptions.length > 0) {
                const randIndex = Math.floor(Math.random() * upgradeOptions.length);
                choices.push(upgradeOptions.splice(randIndex, 1)[0]);
            }

            DOMElements.levelUpModal.innerHTML = `<div class="modal-panel">
                <h2 class="modal-title">레벨 업!</h2>
                <div class="grid grid-cols-1 gap-4">
                    ${choices.map(c => {
                        const weaponData = WEAPONS[c.id];
                        if (c.isNew) {
                             return `<div class="upgrade-card" data-type="new" data-id="${c.id}">
                                 <h3 class="font-bold text-lg text-green-400">새 무기: ${weaponData.name}</h3>
                                 <p class="text-sm text-gray-400">${weaponData.description}</p>
                             </div>`;
                        } else {
                            const nextLevel = c.level + 1;
                            const evolution = weaponData.evolution.find(e => e.level === nextLevel);
                            return `<div class="upgrade-card" data-type="upgrade" data-id="${c.id}">
                                 <h3 class="font-bold text-lg text-yellow-400">${weaponData.name} 강화</h3>
                                 <p class="text-sm text-gray-400">Lv. ${c.level} -> Lv. ${nextLevel}</p>
                                 ${evolution ? `<p class="text-sm text-cyan-400 mt-2">${evolution.description}</p>` : ''}
                             </div>`;
                        }
                    }).join('')}
                </div>
            </div>`;
            DOMElements.levelUpModal.classList.remove('hidden');
            DOMElements.levelUpModal.querySelectorAll('.upgrade-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    const choiceType = e.currentTarget.dataset.type;
                    const weaponId = e.currentTarget.dataset.id;
                    if (choiceType === 'new') {
                        p.activeWeapons.push({ id: weaponId, level: 1, lastFired: 0 });
                    } else {
                        const weaponToUpgrade = p.activeWeapons.find(w => w.id === weaponId);
                        if(weaponToUpgrade) weaponToUpgrade.level++;
                    }
                    recalculatePlayerStats();
                    DOMElements.levelUpModal.classList.add('hidden');
                    gameState.isPaused = false;
                });
            });
        }
        
        // --- INITIALIZE ---
        window.addEventListener('DOMContentLoaded', init);

    </script>
</body>
</html>
